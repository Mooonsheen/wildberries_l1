// Чем отличаются буферизированные и не буферизированные каналы?

// Небуферизованные каналы:

//     Небуферизованный канал не имеет внутреннего буфера для хранения значений.
//     Отправка и получение значений в небуферизованном канале блокируют выполнение горутины до тех пор, пока отправка и получение не будут завершены.
//     Отправка и получение происходят в паре, то есть отправка блокируется, пока другая горутина не получит значение, и наоборот.
//     Это обеспечивает синхронизацию между горутинами и гарантирует, что отправка и получение происходят в правильном порядке.

// Буферизованные каналы:

//     Буферизованный канал имеет внутренний буфер, который может хранить определенное количество значений.
//     Отправка в буферизованный канал (<-) не блокируется, если буфер не заполнен. Она блокируется только в том случае, если буфер полностью заполнен.
//     Получение из буферизованного канала (<-) не блокируется, если буфер не пуст. Оно блокируется только в том случае, если буфер пуст.
//     Буферизованные каналы позволяют асинхронное взаимодействие между горутинами, поскольку отправка и получение могут происходить независимо друг от друга.

package main

// import (
// 	"fmt"
// 	"sync"
// )

// func main() {
// 	wg := sync.WaitGroup{}
// 	// Небуферизованный канал
// 	unbuffered := make(chan int)

// 	// Буферизованный канал с размером буфера 3
// 	buffered := make(chan int, 3)
// 	wg.Add(1)
// 	go func(wg *sync.WaitGroup) {
// 		unbuffered <- 1
// 		buffered <- 2
// 		buffered <- 3
// 		buffered <- 4 // Блокируется, если буфер полностью заполнен
// 		buffered <- 5 // Значение не попадает в канал
// 		wg.Done()
// 	}(&wg)

// 	fmt.Println(<-unbuffered) // Блокируется, пока значение не будет получено
// 	fmt.Println(<-buffered)
// 	fmt.Println(<-buffered)
// 	fmt.Println(<-buffered)
// 	fmt.Println(<-buffered)
// 	fmt.Println(<-buffered)

// 	wg.Wait()

// 	close(buffered)
// 	close(unbuffered)
// }
